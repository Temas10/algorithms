Алгоритмы поиска и сортировки
=
Краткое описание для каждого алгоритма, временная сложность, код. Также для удобства есть все алгоритмы в файлах ```.py```.

Пузырьковая сортировка (Bubble Sort)
-
Пузырьковая сортировка — элементарный алгоритм, основанный на многократном "всплытии" более легких элементов к вершине списка, подобно пузырькам воздуха в воде.

```
def bubble_sort(arr):
    b = len(arr)
    for i in range(b):
        flag = False
        for j in range(0, b - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                flag = True
        if not flag:
            break
    return arr

example = [45, 25, 44, 11, 5, 120, 4]
print(bubble_sort(example))  # [4, 5, 11, 25, 44, 45, 120]
```

Временная сложность: O(n²) в худшем и среднем случаях, O(n) в лучшем случае (для уже отсортированного массива с оптимизацией).

Сортировка вставками (Insertion Sort)
-
Сортировка вставками работает аналогично тому, как мы сортируем игральные карты в руке: берем новую карту и вставляем ее в правильное место среди уже отсортированных.
```
def insertion_sort(arr):
    for i in range(1, len(arr)):
        pos = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > pos:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = pos
    return arr

example = [56, 47, 456, 4, 89, 110, 15]
print(insertion_sort(example)) # [4, 15, 47, 56, 89, 110, 456]
```

Сортировка слиянием (Merge Sort)
-
Сортировка слиянием использует подход "разделяй и властвуй": разбивает список на подсписки, сортирует их, а затем объединяет.

```
def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        left = arr[:mid]
        right = arr[mid:]

        # Рекурсивная сортировка подмассивов
        merge_sort(left)
        merge_sort(right)

        i = j = k = 0

        # Слияние подмассивов
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                arr[k] = left[i]
                i += 1
            else:
                arr[k] = right[j]
                j += 1
            k += 1

        # Проверка оставшихся элементов
        while i < len(left):
            arr[k] = left[i]
            i += 1
            k += 1

        while j < len(right):
            arr[k] = right[j]
            j += 1
            k += 1

    return arr

example = [56, 66, 4, 2, 224, 15, 80]
print(merge_sort(example))  # [2, 4, 15, 56, 66, 80, 224]
```
Временная сложность: O(n log n) во всех случаях, что делает ее более эффективной для больших массивов по сравнению с пузырьковой и сортировкой вставками.

Быстрая сортировка (Quick Sort)
-
Быстрая сортировка — еще один алгоритм типа "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше и больше опорного.
```
def quick_sort(arr):
    if len(arr) <= 1:
        return arr

    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    return quick_sort(left) + middle + quick_sort(right)

example = [64, 28, 21, 18, 63, 14, 81]
print(quick_sort(example))  # [14, 18, 21, 28, 63, 64, 81]
```
Временная сложность: O(n log n) в среднем и лучшем случаях, O(n²) в худшем случае (при неудачном выборе опорного элемента).

Для большинства случаев встроенная функция ```sorted()``` или метод ```.sort()``` будут оптимальным выбором.
```
list.sort(key=None, reverse=False) 
                                   
a = [3, 1, 2]
b = sorted(a)   # b = [1, 2, 3], a остаётся [3, 1, 2]
a.sort()        # a становится [1, 2, 3]
```

Линейный и бинарный поиск
=

Линейный поиск — простейший алгоритм, проверяющий каждый элемент последовательно, пока не найдет искомый или не достигнет конца списка.

Линейный поиск (Linear Search)
-
Линейный поиск — наиболее интуитивный алгоритм поиска, последовательно проверяющий каждый элемент массива.

```
def linear_search(arr, target):
    for i, item in enumerate(arr):
        if item == target:
            return i 
    return -1 

# Пример использования
example = [4, 17, 25, 7, 10, 14, 89]
target = 10
result = linear_search(example, target)
print(f"Элемент {target} найден на позиции {result}" if result != -1 else f"Элемент {target} не найден")
```
Временная сложность: O(n) — в худшем случае придется проверить все n элементов.

Преимущества линейного поиска:

- Работает с неотсортированными массивами
- Прост в реализации
- Эффективен для маленьких массивов
- Не требует дополнительной памяти

Недостатки:

- Неэффективен для больших массивов
- Линейная временная сложность

Бинарный поиск (Binary Search)
-
Бинарный поиск использует подход "разделяй и властвуй", многократно деля отсортированный массив пополам и сужая область поиска.

```
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        # Если элемент найден
        if arr[mid] == target:
            return mid

        # Если элемент меньше среднего, ищем в левой половине
        elif arr[mid] > target:
            right = mid - 1

        # Если элемент больше среднего, ищем в правой половине
        else:
            left = mid + 1

    return -1  # Элемент не найден


sorted_example = [11, 12, 22, 25, 34, 64, 90]
target = 25
result = binary_search(sorted_example, target)
print(f"Элемент {target} найден на позиции {result}" if result != -1 else f"Элемент {target} не найден")
```
Рекурсивная реализация бинарного поиска:
-
```
def binary_search_recursive(arr, target, left=0, right=None):
    if right is None:
        right = len(arr) - 1

    # Базовый случай: элемент не найден
    if left > right:
        return -1

    mid = (left + right) // 2

    # Если элемент найден
    if arr[mid] == target:
        return mid

    # Рекурсивный случай: ищем в левой половине
    elif arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)

    # Рекурсивный случай: ищем в правой половине
    else:
        return binary_search_recursive(arr, target, mid + 1, right)


sorted_example = [7, 9, 20, 4, 11, 64, 71]
target = 11
result = binary_search_recursive(sorted_example, target)
print(f"Элемент {target} найден на позиции {result}" if result != -1 else f"Элемент {target} не найден")
```

Временная сложность: O(log n) — каждая итерация уменьшает размер области поиска вдвое.

Преимущества бинарного поиска:

- Очень эффективен для больших массивов данных
- Логарифмическая временная сложность
- Минимальное количество сравнений

Недостатки:

- Работает только с отсортированными массивами
- Требует произвольного доступа к элементам (не подходит для связных списков)
- Сложнее реализовать корректно (особенно рекурсивную версию)

При работе с Python стоит помнить, что стандартная библиотека содержит модуль ```bisect```, который предоставляет оптимизированные функции для работы с отсортированными списками, включая бинарный поиск:

```
import bisect

def binary_search_with_bisect(arr, target):
    i = bisect.bisect_left(arr, target)
    if i != len(arr) and arr[i] == target:
        return i
    return -1

sorted_example = [11, 12, 22, 25, 34, 64, 90]
target = 34
result = binary_search_with_bisect(sorted_example, target)
print(f"Элемент {target} найден на позиции {result}" if result != -1 else f"Элемент {target} не найден")
```

Выбор между линейным и бинарным поиском зависит от конкретной задачи. Линейный поиск подходит для неотсортированных или маленьких массивов, а бинарный — для больших отсортированных наборов данных, где критична производительность.

Продвинутые алгоритмы сортировки для сложных задач
=
Для решения более сложных задач сортировки и поиска в Python доступны продвинутые алгоритмы, которые предлагают повышенную эффективность в определенных сценариях. Рассмотрим четыре таких алгоритма: сортировку подсчётом, сортировку кучей, поразрядную сортировку и сортировку Шелла.

Сортировка подсчётом (Counting Sort)
-
Сортировка подсчётом — неклассический алгоритм сортировки, который работает, подсчитывая количество вхождений каждого уникального элемента в массиве. Идеально подходит для массивов с небольшим диапазоном значений.

```
def counting_sort(arr):
    # Находим максимальное и минимальное значение для создания массива подсчёта
    max_value = max(arr)
    min_value = min(arr)
    range_of_values = max_value - min_value + 1

    # Создаем массив подсчёта
    count = [0] * range_of_values

    # Подсчитываем количество каждого элемента
    for num in arr:
        count[num - min_value] += 1

    # Восстанавливаем отсортированный массив
    sorted_array = []
    for i in range(range_of_values):
        sorted_array.extend([i + min_value] * count[i])

    return sorted_array

example = [4, 2, 2, 8, 3, 3, 1]
print(counting_sort(example))  # [1, 2, 2, 3, 3, 4, 8]
```
Временная сложность: O(n + k), где n — количество элементов, а k — диапазон значений. Пространственная сложность: O(k).

Сортировка кучей (Heap Sort)
-
Сортировка кучей использует структуру данных "двоичная куча" для построения отсортированного массива. Python предоставляет модуль ```heapq``` для работы с кучами.
```
def heap_sort(arr):
    import heapq

    # Преобразуем исходный массив в кучу
    heap = arr.copy()
    heapq.heapify(heap)

    # Извлекаем элементы из кучи в отсортированном порядке
    sorted_array = []
    while heap:
        sorted_array.append(heapq.heappop(heap))

    return sorted_array

example = [12, 11, 13, 5, 6, 7]
print(heap_sort(example))  # [5, 6, 7, 11, 12, 13]
```
Также можно реализовать сортировку кучей без использования встроенного модуля:
```
def heapify(arr, n, i):
    largest = i          # Инициализируем наибольший элемент как корень
    left = 2 * i + 1      # левый дочерний элемент
    right = 2 * i + 2     # правый дочерний элемент

    # Проверяем, больше ли левый дочерний элемент корня
    if left < n and arr[left] > arr[largest]:
        largest = left

    # Проверяем, больше ли правый дочерний элемент корня
    if right < n and arr[right] > arr[largest]:
        largest = right

    # Если наибольший элемент не корень
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Обмен

        # Рекурсивно приводим к свойствам кучи поддерево
        heapify(arr, n, largest)

def heap_sort_manual(arr):
    n = len(arr)

    # Построение max-heap
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # Извлечение элементов из кучи
    for i in range(n - 1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]  # Обмен
        heapify(arr, i, 0)

    return arr

example = [12, 11, 13, 5, 6, 7]
print(heap_sort_manual(example))  # [5, 6, 7, 11, 12, 13]
```
Временная сложность: O(n log n) во всех случаях. Пространственная сложность: O(1).

Поразрядная сортировка (Radix Sort)
-
Поразрядная сортировка — нестандартный алгоритм сортировки, который работает с числами, сортируя их по разрядам (от младшего к старшему или наоборот).
```
def radix_sort(arr):
    # Находим максимальное число для определения количества цифр
    max_num = max(arr)

    # Выполняем сортировку подсчетом для каждого разряда
    exp = 1
    while max_num // exp > 0:
        counting_sort_by_digit(arr, exp)
        exp *= 10

    return arr

def counting_sort_by_digit(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # Подсчитываем количество каждой цифры
    for i in range(n):
        digit = (arr[i] // exp) % 10
        count[digit] += 1

    # Накапливаем суммы для определения позиций
    for i in range(1, 10):
        count[i] += count[i - 1]

    # Создаем отсортированный по текущему разряду массив
    for i in range(n - 1, -1, -1):
        digit = (arr[i] // exp) % 10
        output[count[digit] - 1] = arr[i]
        count[digit] -= 1

    # Копируем отсортированный массив обратно в исходный
    for i in range(n):
        arr[i] = output[i]

example = [170, 45, 75, 90, 802, 24, 2, 66]
print(radix_sort(example)) # [2, 24, 45, 66, 75, 90, 170, 802]
```
Временная сложность: O(d * (n + k)), где d — количество цифр в наибольшем числе, n — количество элементов, k — диапазон значений цифр (обычно 10). Пространственная сложность: O(n + k).

Сортировка Шелла (Shell Sort)
-
Сортировка Шелла — улучшенная версия сортировки вставками, которая позволяет далеко отстоящим элементам меняться местами раньше, чем близким.
```
def shell_sort(arr):
    n = len(arr)
    # Начинаем с большого промежутка, затем уменьшаем его
    gap = n // 2

    while gap > 0:
        # Выполняем сортировку вставками с текущим промежутком
        for i in range(gap, n):
            temp = arr[i]
            j = i

            # Сдвигаем элементы, которые больше temp и находятся на gap позиций левее
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap

            arr[j] = temp

        gap //= 2

    return arr

example = [12, 34, 54, 2, 3]
print(shell_sort(example))  # [2, 3, 12, 34, 54]
```

Выбор продвинутого алгоритма сортировки зависит от специфики задачи:

- Сортировка подсчётом — для небольших диапазонов целочисленных значений
- Сортировка кучей — для задач с ограниченной памятью и требованием гарантированной производительности
- Поразрядная сортировка — для чисел с большим количеством разрядов или строк одинаковой длины
- Сортировка Шелла — как универсальное решение с хорошей производительностью на практике